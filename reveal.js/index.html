<html><head><title>JWT Presentation</title><script defer="defer" src="main.da745f3d5bf4ebc7f371.js"></script><link href="main.1ef763c29d9f570d4ae6.css" rel="stylesheet"></head><body><div class="reveal"><div class="slides"><section data-background-color="#0f1010"><img src="./assets/images/bg.png" alt=""><p>Created by <a href="https://github.com/Tatsiana-Bivoina" target="_blank">Tatsiana Bivoina</a></p></section><section class="definition"><section data-background-color="#97be97" data-auto-animate><h2>What is JSON Web Token?</h2></section><section data-background-color="#97be97" data-auto-animate><h2>What is JSON Web Token?</h2><p><span>JSON Web Token (JWT)</span> is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object.</p></section><section data-background-color="#97be97" data-auto-animate><h2>What is JSON Web Token?</h2><p><span>JSON Web Token (JWT)</span> is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object.</p><p>This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA.</p></section></section><section class="usage"><section data-background-color="#d8dabd" data-auto-animate><h2>When should you use JSON Web Tokens?</h2></section><section data-background-color="#d8dabd" data-auto-animate><h2>When should you use JSON Web Tokens?</h2><p>Here are some scenarios where JSON Web Tokens are useful:</p></section><section data-background-color="#d8dabd" data-auto-animate><p>Here are some scenarios where JSON Web Tokens are useful:</p><ul class="list-items"><li><span>Authorization: </span>This is the most common scenario for using JWT. Once the user is logged in, each subsequent request will include the JWT, allowing the user to access routes, services, and resources that are permitted with that token.</li></ul></section><section data-background-color="#d8dabd" data-auto-animate><p>Here are some scenarios where JSON Web Tokens are useful:</p><ul class="list-items"><li><span>Authorization: </span>This is the most common scenario for using JWT. Once the user is logged in, each subsequent request will include the JWT, allowing the user to access routes, services, and resources that are permitted with that token.</li><li><span>Information Exchange: </span>JSON Web Tokens are a good way of securely transmitting information between parties. Because JWTs can be signed you can be sure the senders are who they say they are. Additionally, as the signature is calculated using the header and the payload, you can also verify that the content hasn't been tampered with.</li></ul></section></section><section class="structure"><section data-background-color="#97be97"><h2>JWT Structure</h2></section><section data-background-color="#97be97" data-auto-animate><p>As a rule, structurally JWT consists of three parts:</p><ol><li>header</li><li>payload</li><li>signature</li></ol></section><section data-background-color="#97be97" data-auto-animate><p>As a rule, structurally JWT consists of three parts:</p><ol><li>header</li><li>payload</li><li>signature</li></ol><p><b>The header</b> and <b>payload</b> are regular JSON objects that need to be further encoded using the base64url algorithm. The encoded parts are connected to each other, and based on them, <b>the signature</b> is calculated , which also becomes part of the token.</p></section><section data-background-color="#97be97"><img src="./assets/images/teh1-1.png" alt=""></section><section data-background-color="#97be97"><h3>Header</h3><p>The header is the service part of the token. It helps the application determine how the received token should be handled.</p><p>This part is a JSON object and has the following format:</p><pre>
              <code data-trim data-noescape>
                {
                  "typ": "JWT",
                  "alg": "HS256"
                } 
              </code>
            </pre></section><section data-background-color="#97be97"><p>The following fields are present here:</p><ul><li><b>type</b> - token type, for example JWT;</li><li><b>alg</b> is the algorithm used to generate the signature.</li></ul></section><section data-background-color="#97be97"><h3>Payload</h3><p>The payload carries any information that helps the application in some way identify the user.</p><p>This part is a JSON object and has the following format:</p><pre>
              <code data-trim data-noescape>
              {
                "id": "1337",
                "username": "bizone",
                "iat": 1594209600,
                "role": "user"
              }
              </code>
            </pre></section><section data-background-color="#97be97"><p>The following fields are present here:</p><ul class="list-items"><li><b>iss</b> - the application that created the token;</li><li><b>sub</b> - destination JWT;</li><li><b>aud</b> - array of token recipients;</li><li><b>exp</b> - date and time specified in milliseconds since 01/01/1970, before which the JWT will be valid;</li><li><b>nbf</b> - date and time specified in milliseconds since 01/01/1970, before which the JWT will not be valid;</li><li><b>iat</b> - date and time of JWT creation, specified in milliseconds since 01/01/1970;</li><li><b>jti</b> - unique token identifier;</li><li><b>role</b> - user role, for example admin, user, guest.</li></ul></section><section data-background-color="#97be97"><h3>Signature</h3><p>The signature is generated as follows.</p><p>The header and payload are base64url encoded and then concatenated into a single string using a dot ( ".") as a delimiter.</p><p>A signature is generated (in our example, using the HMAC-SHA256 algorithm), which is added to the source string also through a dot.</p></section><section data-background-color="#97be97"><p>In pseudocode, the algorithm looks something like this:</p><pre>
              <code data-trim>
      signature = HMACSHA256(
        base64UrlEncode(header) + "." 
        + base64UrlEncode(payload),
        SECRET_KEY
      )
      
      JWT = base64UrlEncode(header) + "." 
      + base64UrlEncode(payload) + "." 
      + base64UrlEncode(signature)                
              </code>
            </pre></section><section data-background-color="#97be97"><p>The generated JWT is sent to the client, where it is stored in localStorage or sessionStorage, and will be sent from the client to the server on every HTTP request in the Authorization header.</p><pre>
              <code data-trim>
                Authorization: Bearer {token}              
              </code>
            </pre><p>The server, in turn, when accessing routes that require authorization, extracts data from the token and checks the validity of the token and the presence of the user specified in the JWT.</p></section></section><section class="benefits"><section data-background-color="#d8dabd" data-auto-animate><h2>Benefits of JWTs</h2></section><section data-background-color="#d8dabd" data-auto-animate><h2>Benefits of JWTs</h2><ul class="list-items"><li>the token approach allows you not to store information about all issued tokens, as in the classical scheme</li></ul></section><section data-background-color="#d8dabd" data-auto-animate><h2>Benefits of JWTs</h2><ul class="list-items"><li>the token approach allows you not to store information about all issued tokens, as in the classical scheme</li><li>the application does not have to deal with issuing and validating tokens on its own, often a separate authentication service is used for these purposes</li></ul></section><section data-background-color="#d8dabd" data-auto-animate><h2>Benefits of JWTs</h2><ul class="list-items"><li>the token approach allows you not to store information about all issued tokens, as in the classical scheme</li><li>the application does not have to deal with issuing and validating tokens on its own, often a separate authentication service is used for these purposes</li><li>when using a separate authentication service, it becomes possible to organize a single entry point to various services with the same credentials</li></ul></section><section data-background-color="#d8dabd" data-auto-animate><h2>Benefits of JWTs</h2><ul class="list-items"><li>the token approach allows you not to store information about all issued tokens, as in the classical scheme</li><li>the application does not have to deal with issuing and validating tokens on its own, often a separate authentication service is used for these purposes</li><li>when using a separate authentication service, it becomes possible to organize a single entry point to various services with the same credentials</li><li>the application can store almost any data in the payload part, which, with a competent application architecture, can significantly increase performance.</li></ul></section></section><section class="tokens"><section data-background-color="#97be97"><h2>Refresh and Access Tokens</h2></section><section data-background-color="#97be97"><p>In modern JWT-based authentication schemes, after passing authentication, the user receives two tokens:</p><ul><li><span>access token </span>- JWT, based on which the application identifies and authorizes the user;</li><li><span>refresh token</span> - an arbitrary format token, stored in the database, which is used to update the access token.</li></ul></section><section data-background-color="#97be97"><p>Here are some ways to store your tokens:</p><ul><li>Store Access Token in localStorage</li><li>Store the Access Token in a cookie with httpOnly</li><li>Store the Refresh Token in a httpOnly cookie</li></ul></section><section data-background-color="#97be97"><p>The authentication scheme in this case looks like this:</p><img src="./assets/images/JWT_tokens.png" alt=""></section></section><section class="libraries"><section data-background-color="#d8dabd" data-auto-animate><h2>Libraries for Token Signing/Verification</h2></section><section data-background-color="#d8dabd" data-auto-animate><h2>Libraries for Token Signing/Verification</h2><p>Node.js:</p><ul><li>jsonwebtoken</li><li>jose</li><li>aws-jwt-verify</li></ul></section><section data-background-color="#d8dabd" data-auto-animate><h2>Libraries for Token Signing/Verification</h2><p>JavaScript:</p><ul><li>jsrsasign</li><li>jose</li><li>jose-jwe-jws</li><li>node-jose</li></ul></section><section data-background-color="#d8dabd" data-auto-animate><h2>Libraries for Token Signing/Verification</h2><p>JavaScript:</p><ul><li>jsrsasign</li><li>jose</li><li>jose-jwe-jws</li><li>node-jose</li></ul><p>You can find the full list of libraries on the <a href="https://jwt.io/libraries">official JWT website</a></p></section></section><section class="jwt-authentication" data-background-color="#97be97"><h2>Implementing a simple and easy JWT authentication system with TypeScript and Node</h2><a href="https://nozzlegear.com/blog/implementing-a-jwt-auth-system-with-typescript-and-node" target="_blank">Follow</a></section><section class="conclusion"><section data-background-color="#d8dabd" data-auto-animate><h2>Conclusion</h2></section><section data-background-color="#d8dabd" data-auto-animate><h2>Conclusion</h2><p>JSON Web Tokens are a popular and convenient technology. When used correctly, JWT eliminates common errors of insufficient authorization, allows you to easily and conveniently distribute information flows between services, organize a single entry point to different services with the same credentials, and even improve service performance.</p><p>However, if JWT is used incorrectly, you can expose your system to significant risks, up to compromising the accounts of absolutely all users of the system.</p></section><section data-background-color="#d8dabd"><p>So, to use JWT safely, you should:</p><ul class="list-items"><li>use a secure connection when transferring tokens;</li><li>do not transfer sensitive user data in tokens;</li><li>limit JWT lifetime and use the refresh tokens mechanism;</li><li>use key phrases of great length;</li><li>ensure periodic change of the key phrase;</li><li>maintain a white list of allowed signature algorithms on the application side;</li><li>in the ideal case, work strictly with one signature algorithm;</li><li>choose well-known and proven libraries for working with JWT;</li><li>always validate and sanitize the data received from the user.</li></ul></section></section><section data-background-color="#97be97"><h2>Thank you for your attention</h2></section></div></div></body></html>